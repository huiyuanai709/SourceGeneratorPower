using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGeneratorPower.HttpClient
{
    [Generator]
    public class HttpClientGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new HttpClientSyntax());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is HttpClientSyntax receiver))
            {
                return;
            }

            var httpClientVisitor = new HttpClientVisitor();
            foreach (var assemblySymbol in context.Compilation.SourceModule.ReferencedAssemblySymbols
                         .Where(x => x.Identity.PublicKeyToken == ImmutableArray<byte>.Empty))
            {
                assemblySymbol.Accept(httpClientVisitor);
            }

            receiver.TypeSymbols.AddRange(httpClientVisitor.GetHttpClientTypes());
            var extensionSource = new StringBuilder($@"
using SourceGeneratorPower.HttpClient;
using Microsoft.Extensions.Configuration;

namespace Microsoft.Extensions.DependencyInjection
{{
    public static class ScanInjectOptions
    {{
        public static void AddGeneratedHttpClient(this IServiceCollection services)
        {{
");

            foreach (var typeSymbol in receiver.TypeSymbols)
            {
                var sourceText = ProcessInterface(typeSymbol);
                var sourceTextFormatted = CSharpSyntaxTree
                    .ParseText(sourceText, new CSharpParseOptions(LanguageVersion.CSharp8)).GetRoot()
                    .NormalizeWhitespace().SyntaxTree.GetText().ToString();
                context.AddSource($"{typeSymbol.ToDisplayString()}.AutoGenerated.cs",
                    SourceText.From(sourceTextFormatted, Encoding.UTF8));
                extensionSource.AppendLine(
                    $@"services.AddScoped<global::{typeSymbol.ToDisplayString()}, global::{typeSymbol.ContainingNamespace.ToDisplayString()}.{typeSymbol.Name.Substring(1)}>();");
            }

            extensionSource.AppendLine("}}}");
            var extensionTextFormatted = CSharpSyntaxTree
                .ParseText(extensionSource.ToString(), new CSharpParseOptions(LanguageVersion.CSharp8)).GetRoot()
                .NormalizeWhitespace().SyntaxTree.GetText().ToString();
            context.AddSource($"SourceGeneratorPower.HttpClientExtension.AutoGenerated.cs",
                SourceText.From(extensionTextFormatted, Encoding.UTF8));
        }

        private string ProcessInterface(INamedTypeSymbol typeSymbol)
        {
            var className = typeSymbol.Name.Substring(1);
            var usingList = GenerateUsing(typeSymbol);
            var source = new StringBuilder();
            var constructor = GenerateConstructor(typeSymbol);
            foreach (var usingStr in usingList)
            {
                source.AppendLine(usingStr);
            }

            source.AppendLine($@"
namespace {typeSymbol.ContainingNamespace.ToDisplayString()}
{{
    public class {className} : {typeSymbol.ToDisplayString()}
    {{
                ");
            source.Append(' ', 8);
            source.AppendLine(constructor);
            source.AppendLine(GenerateMethods(typeSymbol));

            source.AppendLine("}");
            source.AppendLine("}");
            return source.ToString();
        }

        private List<string> GenerateUsing(ISymbol typeSymbol)
        {
            return typeSymbol.GetAttributes().Where(at => at.AttributeClass.ToDisplayString() == "")
                .SelectMany(at => at.ConstructorArguments.Select(t => $"using {t.Value};"))
                .Concat(new[]
                {
                    "using System.Net.Http.Headers;",
                    "using System.Text.Json;",
                    "using System.Net.Http.Json;",
                    "using System.Web;",
                    "using System.Threading.Tasks;"
                })
                .ToList();
        }

        private string GenerateMethods(INamedTypeSymbol typeSymbol)
        {
            var source = new StringBuilder();
            var httpClientName = typeSymbol.GetAttributes()
                .First(x => x.AttributeClass.ToDisplayString() == "SourceGeneratorPower.HttpClient.HttpClientAttribute")
                .ConstructorArguments[0].Value.ToString();
            foreach (var member in typeSymbol.GetMembers())
            {
                if (!(member is IMethodSymbol methodSymbol))
                {
                    continue;
                }

                var (httpMethod, requestUri) = GetHttpMethod(methodSymbol);
                if (httpMethod is null)
                {
                    continue;
                }

                if (httpMethod == "Get")
                {
                    source.AppendLine(GenerateGetMethod(typeSymbol, methodSymbol, httpClientName, requestUri));
                    continue;
                }

                if (httpMethod == "Delete")
                {
                    source.AppendLine(GenerateDeleteMethod(typeSymbol, methodSymbol, httpClientName, httpMethod,
                        requestUri));
                    continue;
                }

                source.AppendLine(GenerateOtherMethod(typeSymbol, methodSymbol, httpClientName, httpMethod,
                    requestUri));
            }

            return source.ToString();
        }

        private string GenerateGetMethod(ITypeSymbol typeSymbol, IMethodSymbol methodSymbol, string httpClientName,
            string requestUri)
        {
            var returnType = (methodSymbol.ReturnType as INamedTypeSymbol).TypeArguments[0].ToDisplayString();
            var cancellationToken = methodSymbol.Parameters.Last().Name;
            var source = GenerateHttpClient(typeSymbol, methodSymbol, httpClientName);
            source.AppendLine($@"var response = await httpClient.GetAsync($""{requestUri}"", {cancellationToken});");
            source.AppendLine("response!.EnsureSuccessStatusCode();");
            source.AppendLine(
                $@"return (await response.Content.ReadFromJsonAsync<{returnType}>(cancellationToken: {cancellationToken})!)!;");
            source.AppendLine("}");
            return source.ToString();
        }

        private string GenerateDeleteMethod(ITypeSymbol typeSymbol, IMethodSymbol methodSymbol, string httpClientName,
            string httpMethod, string requestUri)
        {
            var returnType = (methodSymbol.ReturnType as INamedTypeSymbol).TypeArguments[0].ToDisplayString();
            var cancellationToken = methodSymbol.Parameters.Last().Name;
            var source = GenerateHttpClient(typeSymbol, methodSymbol, httpClientName);
            source.AppendLine(
                $@"var response = await httpClient.{httpMethod}Async($""{requestUri}"", {cancellationToken});");
            source.AppendLine("response!.EnsureSuccessStatusCode();");
            source.AppendLine(
                $@"return (await response.Content.ReadFromJsonAsync<{returnType}>(cancellationToken: {cancellationToken})!)!;");
            source.AppendLine("}");
            return source.ToString();
        }

        private string GenerateOtherMethod(ITypeSymbol typeSymbol, IMethodSymbol methodSymbol, string httpClientName,
            string httpMethod, string requestUri)
        {
            var returnType = (methodSymbol.ReturnType as INamedTypeSymbol).TypeArguments[0].ToDisplayString();
            var cancellationToken = methodSymbol.Parameters.Last().Name;
            var source = GenerateHttpClient(typeSymbol, methodSymbol, httpClientName);
            source.AppendLine(
                $@"var jsonContent = JsonContent.Create({methodSymbol.Parameters[methodSymbol.Parameters.Length - 2].Name}, new MediaTypeHeaderValue(""application/json""){{CharSet = ""UTF-8""}});");
            source.AppendLine(
                $@"var response = await httpClient.{httpMethod}Async($""{requestUri}"", jsonContent, {cancellationToken});");
            source.AppendLine("response!.EnsureSuccessStatusCode();");
            source.AppendLine(
                $@"return (await response.Content.ReadFromJsonAsync<{returnType}>(cancellationToken: {cancellationToken})!)!;");
            source.AppendLine("}");
            return source.ToString();
        }

        private StringBuilder GenerateHttpClient(ITypeSymbol typeSymbol, IMethodSymbol methodSymbol,
            string httpClientName)
        {
            var source = new StringBuilder($@"
public async {methodSymbol.ReturnType} {methodSymbol.Name}({string.Join(", ", methodSymbol.Parameters.Select(p => $"{p.Type} {p.Name}"))})");
            source.AppendLine("{");
            source.AppendLine($@"var httpClient = _httpClientFactory.CreateClient(""{httpClientName}"");");
            var dict = GetHeaders(typeSymbol, methodSymbol);
            foreach (var header in dict)
            {
                source.AppendLine(
                    $@"httpClient.DefaultRequestHeaders.Add(""{header.Key}"", HttpUtility.UrlEncode($""{header.Value}""));");
            }

            return source;
        }

        private Dictionary<string, string> GetHeaders(ITypeSymbol typeSymbol, IMethodSymbol methodSymbol)
        {
            var dict = new Dictionary<string, string>();
            foreach (var attributeData in typeSymbol.GetAttributes().Where(x =>
                         x.AttributeClass!.ToDisplayString() == "SourceGeneratorPower.HttpClient.HeaderAttribute"))
            {
                dict.Add(attributeData.ConstructorArguments[0].Value!.ToString(),
                    attributeData.ConstructorArguments[1].Value!.ToString());
            }

            foreach (var attributeData in methodSymbol.GetAttributes().Where(x =>
                         x.AttributeClass!.ToDisplayString() == "SourceGeneratorPower.HttpClient.HeaderAttribute"))
            {
                dict.Add(attributeData.ConstructorArguments[0].Value!.ToString(),
                    attributeData.ConstructorArguments[1].Value!.ToString());
            }

            return dict;
        }

        private Tuple<string, string> GetHttpMethod(IMethodSymbol methodSymbol)
        {
            var methodAttributes = methodSymbol.GetAttributes();
            var httpGetAttribute = methodAttributes.FirstOrDefault(x =>
                x.AttributeClass!.ToDisplayString() == "SourceGeneratorPower.HttpClient.HttpMethod.HttpGetAttribute");
            if (httpGetAttribute != null)
            {
                return new Tuple<string, string>("Get", httpGetAttribute.ConstructorArguments[0].Value!.ToString());
            }

            var httpPostAttribute = methodAttributes.FirstOrDefault(x =>
                x.AttributeClass!.ToDisplayString() == "SourceGeneratorPower.HttpClient.HttpMethod.HttpPostAttribute");
            if (httpPostAttribute != null)
            {
                return new Tuple<string, string>("Post", httpPostAttribute.ConstructorArguments[0].Value!.ToString());
            }

            var httpPutAttribute = methodAttributes.FirstOrDefault(x =>
                x.AttributeClass!.ToDisplayString() == "SourceGeneratorPower.HttpClient.HttpMethod.HttpPutAttribute");
            if (httpPutAttribute != null)
            {
                return new Tuple<string, string>("Put", httpPutAttribute.ConstructorArguments[0].Value!.ToString());
            }

            var httpDeleteAttribute = methodAttributes.FirstOrDefault(x =>
                x.AttributeClass!.ToDisplayString() ==
                "SourceGeneratorPower.HttpClient.HttpMethod.HttpDeleteAttribute");
            if (httpDeleteAttribute != null)
            {
                return new Tuple<string, string>("Delete",
                    httpDeleteAttribute.ConstructorArguments[0].Value!.ToString());
            }

            var httpPatchAttribute = methodAttributes.FirstOrDefault(x =>
                x.AttributeClass!.ToDisplayString() == "SourceGeneratorPower.HttpClient.HttpMethod.HttpPatchAttribute");
            if (httpPatchAttribute != null)
            {
                return new Tuple<string, string>("Patch", httpPatchAttribute.ConstructorArguments[0].Value!.ToString());
            }

            return null;
        }

        private string GenerateConstructor(ISymbol typeSymbol)
        {
            var className = typeSymbol.Name.Substring(1);
            var requiredServices = typeSymbol.GetAttributes().Where(x =>
                x.AttributeClass.ToDisplayString() == "SourceGeneratorPower.HttpClient.RequiredServiceAttribute");
            var constructorBuilder = new StringBuilder();
            var dict = new Dictionary<string, string>();
            dict.Add("_httpClientFactory", "IHttpClientFactory");
            foreach (var requiredService in requiredServices)
            {
                var services = requiredService.ConstructorArguments;
                dict.Add(services[1].Value.ToString(), services[0].Value.ToString());
            }

            foreach (var keyValuePair in dict)
            {
                constructorBuilder.AppendLine($"private readonly {keyValuePair.Value} {keyValuePair.Key};");
            }

            constructorBuilder.AppendLine($"public {className}(");

            constructorBuilder.Append(string.Join(",", dict.Select(x => $"{x.Value} {x.Key.Substring(1)}")));

            constructorBuilder.AppendLine(")");
            constructorBuilder.AppendLine("{");
            foreach (var key in dict.Keys)
            {
                constructorBuilder.AppendLine($"{key} = {key.Substring(1)};");
            }

            constructorBuilder.AppendLine("}");
            return constructorBuilder.ToString();
        }

        class HttpClientSyntax : ISyntaxContextReceiver
        {
            public List<INamedTypeSymbol> TypeSymbols { get; set; } = new List<INamedTypeSymbol>();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                if (context.Node is InterfaceDeclarationSyntax ids && ids.AttributeLists.Count > 0)
                {
                    var typeSymbol = ModelExtensions.GetDeclaredSymbol(context.SemanticModel, ids) as INamedTypeSymbol;
                    if (typeSymbol!.GetAttributes().Any(x =>
                            x.AttributeClass!.ToDisplayString() ==
                            "SourceGeneratorPower.HttpClient.HttpClientAttribute"))
                    {
                        TypeSymbols.Add(typeSymbol);
                    }
                }
            }
        }

        class HttpClientVisitor : SymbolVisitor
        {
            private readonly HashSet<INamedTypeSymbol> _httpClientTypeSymbols;

            public HttpClientVisitor()
            {
                _httpClientTypeSymbols = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
            }

            public ImmutableArray<INamedTypeSymbol> GetHttpClientTypes() => _httpClientTypeSymbols.ToImmutableArray();

            public override void VisitAssembly(IAssemblySymbol symbol)
            {
                symbol.GlobalNamespace.Accept(this);
            }

            public override void VisitNamespace(INamespaceSymbol symbol)
            {
                foreach (var namespaceOrTypeSymbol in symbol.GetMembers())
                {
                    namespaceOrTypeSymbol.Accept(this);
                }
            }

            public override void VisitNamedType(INamedTypeSymbol symbol)
            {
                if (symbol.DeclaredAccessibility != Accessibility.Public)
                {
                    return;
                }

                if (symbol.GetAttributes().Any(x =>
                        x.AttributeClass!.ToDisplayString() == "SourceGeneratorPower.HttpClient.HttpClientAttribute"))
                {
                    _httpClientTypeSymbols.Add(symbol);
                }

                var nestedTypes = symbol.GetMembers();
                if (nestedTypes.IsDefaultOrEmpty)
                {
                    return;
                }

                foreach (var nestedType in nestedTypes)
                {
                    nestedType.Accept(this);
                }
            }
        }
    }
}